// Generated by Ignite ignite.com/cli
import { SigningStargateClient } from "@cosmjs/stargate";
import { Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { Api } from "./rest";
import { ValidatorSlashEvents } from "./types/cosmos/distribution/v1beta1/distribution";
import { QueryDelegatorWithdrawAddressRequest } from "./types/cosmos/distribution/v1beta1/query";
import { MsgFundCommunityPoolResponse } from "./types/cosmos/distribution/v1beta1/tx";
import { MsgDepositValidatorRewardsPoolResponse } from "./types/cosmos/distribution/v1beta1/tx";
import { QueryValidatorCommissionRequest } from "./types/cosmos/distribution/v1beta1/query";
import { QueryValidatorCommissionResponse } from "./types/cosmos/distribution/v1beta1/query";
import { QueryDelegationRewardsResponse } from "./types/cosmos/distribution/v1beta1/query";
import { QueryDelegationTotalRewardsRequest } from "./types/cosmos/distribution/v1beta1/query";
import { DelegatorStartingInfo } from "./types/cosmos/distribution/v1beta1/distribution";
import { ValidatorHistoricalRewardsRecord } from "./types/cosmos/distribution/v1beta1/genesis";
import { DelegatorStartingInfoRecord } from "./types/cosmos/distribution/v1beta1/genesis";
import { ValidatorHistoricalRewards } from "./types/cosmos/distribution/v1beta1/distribution";
import { ValidatorCurrentRewardsRecord } from "./types/cosmos/distribution/v1beta1/genesis";
import { QueryValidatorOutstandingRewardsResponse } from "./types/cosmos/distribution/v1beta1/query";
import { QueryDelegationRewardsRequest } from "./types/cosmos/distribution/v1beta1/query";
import { MsgSetWithdrawAddressResponse } from "./types/cosmos/distribution/v1beta1/tx";
import { MsgDepositValidatorRewardsPool } from "./types/cosmos/distribution/v1beta1/tx";
import { MsgCommunityPoolSpendResponse } from "./types/cosmos/distribution/v1beta1/tx";
import { GenesisState } from "./types/cosmos/distribution/v1beta1/genesis";
import { CommunityPoolSpendProposal } from "./types/cosmos/distribution/v1beta1/distribution";
import { QueryCommunityPoolResponse } from "./types/cosmos/distribution/v1beta1/query";
import { MsgWithdrawDelegatorReward } from "./types/cosmos/distribution/v1beta1/tx";
import { MsgWithdrawValidatorCommissionResponse } from "./types/cosmos/distribution/v1beta1/tx";
import { MsgCommunityPoolSpend } from "./types/cosmos/distribution/v1beta1/tx";
import { ValidatorOutstandingRewardsRecord } from "./types/cosmos/distribution/v1beta1/genesis";
import { MsgWithdrawDelegatorRewardResponse } from "./types/cosmos/distribution/v1beta1/tx";
import { Params } from "./types/cosmos/distribution/v1beta1/distribution";
import { CommunityPoolSpendProposalWithDeposit } from "./types/cosmos/distribution/v1beta1/distribution";
import { QueryParamsResponse } from "./types/cosmos/distribution/v1beta1/query";
import { QueryValidatorOutstandingRewardsRequest } from "./types/cosmos/distribution/v1beta1/query";
import { QueryValidatorSlashesRequest } from "./types/cosmos/distribution/v1beta1/query";
import { MsgWithdrawValidatorCommission } from "./types/cosmos/distribution/v1beta1/tx";
import { MsgFundCommunityPool } from "./types/cosmos/distribution/v1beta1/tx";
import { MsgUpdateParams } from "./types/cosmos/distribution/v1beta1/tx";
import { QueryDelegationTotalRewardsResponse } from "./types/cosmos/distribution/v1beta1/query";
import { ValidatorOutstandingRewards } from "./types/cosmos/distribution/v1beta1/distribution";
import { DelegationDelegatorReward } from "./types/cosmos/distribution/v1beta1/distribution";
import { QueryValidatorDistributionInfoRequest } from "./types/cosmos/distribution/v1beta1/query";
import { QueryParamsRequest } from "./types/cosmos/distribution/v1beta1/query";
import { QueryValidatorSlashesResponse } from "./types/cosmos/distribution/v1beta1/query";
import { QueryCommunityPoolRequest } from "./types/cosmos/distribution/v1beta1/query";
import { ValidatorAccumulatedCommissionRecord } from "./types/cosmos/distribution/v1beta1/genesis";
import { ValidatorAccumulatedCommission } from "./types/cosmos/distribution/v1beta1/distribution";
import { MsgUpdateParamsResponse } from "./types/cosmos/distribution/v1beta1/tx";
import { DelegatorWithdrawInfo } from "./types/cosmos/distribution/v1beta1/genesis";
import { ValidatorSlashEventRecord } from "./types/cosmos/distribution/v1beta1/genesis";
import { ValidatorCurrentRewards } from "./types/cosmos/distribution/v1beta1/distribution";
import { QueryValidatorDistributionInfoResponse } from "./types/cosmos/distribution/v1beta1/query";
import { QueryDelegatorValidatorsResponse } from "./types/cosmos/distribution/v1beta1/query";
import { QueryDelegatorWithdrawAddressResponse } from "./types/cosmos/distribution/v1beta1/query";
import { MsgSetWithdrawAddress } from "./types/cosmos/distribution/v1beta1/tx";
import { FeePool } from "./types/cosmos/distribution/v1beta1/distribution";
import { ValidatorSlashEvent } from "./types/cosmos/distribution/v1beta1/distribution";
import { QueryDelegatorValidatorsRequest } from "./types/cosmos/distribution/v1beta1/query";
export { ValidatorSlashEvents, QueryDelegatorWithdrawAddressRequest, MsgFundCommunityPoolResponse, MsgDepositValidatorRewardsPoolResponse, QueryValidatorCommissionRequest, QueryValidatorCommissionResponse, QueryDelegationRewardsResponse, QueryDelegationTotalRewardsRequest, DelegatorStartingInfo, ValidatorHistoricalRewardsRecord, DelegatorStartingInfoRecord, ValidatorHistoricalRewards, ValidatorCurrentRewardsRecord, QueryValidatorOutstandingRewardsResponse, QueryDelegationRewardsRequest, MsgSetWithdrawAddressResponse, MsgDepositValidatorRewardsPool, MsgCommunityPoolSpendResponse, GenesisState, CommunityPoolSpendProposal, QueryCommunityPoolResponse, MsgWithdrawDelegatorReward, MsgWithdrawValidatorCommissionResponse, MsgCommunityPoolSpend, ValidatorOutstandingRewardsRecord, MsgWithdrawDelegatorRewardResponse, Params, CommunityPoolSpendProposalWithDeposit, QueryParamsResponse, QueryValidatorOutstandingRewardsRequest, QueryValidatorSlashesRequest, MsgWithdrawValidatorCommission, MsgFundCommunityPool, MsgUpdateParams, QueryDelegationTotalRewardsResponse, ValidatorOutstandingRewards, DelegationDelegatorReward, QueryValidatorDistributionInfoRequest, QueryParamsRequest, QueryValidatorSlashesResponse, QueryCommunityPoolRequest, ValidatorAccumulatedCommissionRecord, ValidatorAccumulatedCommission, MsgUpdateParamsResponse, DelegatorWithdrawInfo, ValidatorSlashEventRecord, ValidatorCurrentRewards, QueryValidatorDistributionInfoResponse, QueryDelegatorValidatorsResponse, QueryDelegatorWithdrawAddressResponse, MsgSetWithdrawAddress, FeePool, ValidatorSlashEvent, QueryDelegatorValidatorsRequest };
export const registry = new Registry(msgTypes);
function getStructure(template) {
    const structure = { fields: [] };
    for (let [key, value] of Object.entries(template)) {
        let field = { name: key, type: typeof value };
        structure.fields.push(field);
    }
    return structure;
}
const defaultFee = {
    amount: [],
    gas: "200000",
};
export const txClient = ({ signer, prefix, addr } = { addr: "http://localhost:26657", prefix: "cosmos" }) => {
    return {
        async sendValidatorSlashEvents({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValidatorSlashEvents: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.validatorSlashEvents({ value: ValidatorSlashEvents.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValidatorSlashEvents: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegatorWithdrawAddressRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegatorWithdrawAddressRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryDelegatorWithdrawAddressRequest({ value: QueryDelegatorWithdrawAddressRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegatorWithdrawAddressRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgFundCommunityPoolResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgFundCommunityPoolResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgFundCommunityPoolResponse({ value: MsgFundCommunityPoolResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgFundCommunityPoolResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgDepositValidatorRewardsPoolResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgDepositValidatorRewardsPoolResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgDepositValidatorRewardsPoolResponse({ value: MsgDepositValidatorRewardsPoolResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgDepositValidatorRewardsPoolResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorCommissionRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorCommissionRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryValidatorCommissionRequest({ value: QueryValidatorCommissionRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorCommissionRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorCommissionResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorCommissionResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryValidatorCommissionResponse({ value: QueryValidatorCommissionResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorCommissionResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegationRewardsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegationRewardsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryDelegationRewardsResponse({ value: QueryDelegationRewardsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegationRewardsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegationTotalRewardsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegationTotalRewardsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryDelegationTotalRewardsRequest({ value: QueryDelegationTotalRewardsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegationTotalRewardsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDelegatorStartingInfo({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDelegatorStartingInfo: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.delegatorStartingInfo({ value: DelegatorStartingInfo.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDelegatorStartingInfo: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendValidatorHistoricalRewardsRecord({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValidatorHistoricalRewardsRecord: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.validatorHistoricalRewardsRecord({ value: ValidatorHistoricalRewardsRecord.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValidatorHistoricalRewardsRecord: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDelegatorStartingInfoRecord({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDelegatorStartingInfoRecord: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.delegatorStartingInfoRecord({ value: DelegatorStartingInfoRecord.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDelegatorStartingInfoRecord: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendValidatorHistoricalRewards({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValidatorHistoricalRewards: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.validatorHistoricalRewards({ value: ValidatorHistoricalRewards.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValidatorHistoricalRewards: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendValidatorCurrentRewardsRecord({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValidatorCurrentRewardsRecord: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.validatorCurrentRewardsRecord({ value: ValidatorCurrentRewardsRecord.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValidatorCurrentRewardsRecord: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorOutstandingRewardsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorOutstandingRewardsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryValidatorOutstandingRewardsResponse({ value: QueryValidatorOutstandingRewardsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorOutstandingRewardsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegationRewardsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegationRewardsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryDelegationRewardsRequest({ value: QueryDelegationRewardsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegationRewardsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetWithdrawAddressResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetWithdrawAddressResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgSetWithdrawAddressResponse({ value: MsgSetWithdrawAddressResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetWithdrawAddressResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgDepositValidatorRewardsPool({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgDepositValidatorRewardsPool: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgDepositValidatorRewardsPool({ value: MsgDepositValidatorRewardsPool.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgDepositValidatorRewardsPool: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCommunityPoolSpendResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCommunityPoolSpendResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgCommunityPoolSpendResponse({ value: MsgCommunityPoolSpendResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCommunityPoolSpendResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGenesisState({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.genesisState({ value: GenesisState.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendCommunityPoolSpendProposal({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendCommunityPoolSpendProposal: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.communityPoolSpendProposal({ value: CommunityPoolSpendProposal.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendCommunityPoolSpendProposal: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryCommunityPoolResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryCommunityPoolResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryCommunityPoolResponse({ value: QueryCommunityPoolResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryCommunityPoolResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgWithdrawDelegatorReward({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgWithdrawDelegatorReward: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgWithdrawDelegatorReward({ value: MsgWithdrawDelegatorReward.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgWithdrawDelegatorReward: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgWithdrawValidatorCommissionResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgWithdrawValidatorCommissionResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgWithdrawValidatorCommissionResponse({ value: MsgWithdrawValidatorCommissionResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgWithdrawValidatorCommissionResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCommunityPoolSpend({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCommunityPoolSpend: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgCommunityPoolSpend({ value: MsgCommunityPoolSpend.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCommunityPoolSpend: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendValidatorOutstandingRewardsRecord({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValidatorOutstandingRewardsRecord: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.validatorOutstandingRewardsRecord({ value: ValidatorOutstandingRewardsRecord.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValidatorOutstandingRewardsRecord: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgWithdrawDelegatorRewardResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgWithdrawDelegatorRewardResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgWithdrawDelegatorRewardResponse({ value: MsgWithdrawDelegatorRewardResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgWithdrawDelegatorRewardResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendParams({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.params({ value: Params.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendParams: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendCommunityPoolSpendProposalWithDeposit({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendCommunityPoolSpendProposalWithDeposit: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.communityPoolSpendProposalWithDeposit({ value: CommunityPoolSpendProposalWithDeposit.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendCommunityPoolSpendProposalWithDeposit: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryParamsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorOutstandingRewardsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorOutstandingRewardsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryValidatorOutstandingRewardsRequest({ value: QueryValidatorOutstandingRewardsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorOutstandingRewardsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorSlashesRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorSlashesRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryValidatorSlashesRequest({ value: QueryValidatorSlashesRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorSlashesRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgWithdrawValidatorCommission({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgWithdrawValidatorCommission: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgWithdrawValidatorCommission({ value: MsgWithdrawValidatorCommission.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgWithdrawValidatorCommission: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgFundCommunityPool({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgFundCommunityPool: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgFundCommunityPool({ value: MsgFundCommunityPool.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgFundCommunityPool: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateParams({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegationTotalRewardsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegationTotalRewardsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryDelegationTotalRewardsResponse({ value: QueryDelegationTotalRewardsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegationTotalRewardsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendValidatorOutstandingRewards({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValidatorOutstandingRewards: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.validatorOutstandingRewards({ value: ValidatorOutstandingRewards.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValidatorOutstandingRewards: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDelegationDelegatorReward({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDelegationDelegatorReward: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.delegationDelegatorReward({ value: DelegationDelegatorReward.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDelegationDelegatorReward: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorDistributionInfoRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorDistributionInfoRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryValidatorDistributionInfoRequest({ value: QueryValidatorDistributionInfoRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorDistributionInfoRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryParamsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorSlashesResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorSlashesResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryValidatorSlashesResponse({ value: QueryValidatorSlashesResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorSlashesResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryCommunityPoolRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryCommunityPoolRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryCommunityPoolRequest({ value: QueryCommunityPoolRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryCommunityPoolRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendValidatorAccumulatedCommissionRecord({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValidatorAccumulatedCommissionRecord: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.validatorAccumulatedCommissionRecord({ value: ValidatorAccumulatedCommissionRecord.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValidatorAccumulatedCommissionRecord: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendValidatorAccumulatedCommission({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValidatorAccumulatedCommission: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.validatorAccumulatedCommission({ value: ValidatorAccumulatedCommission.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValidatorAccumulatedCommission: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateParamsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDelegatorWithdrawInfo({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDelegatorWithdrawInfo: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.delegatorWithdrawInfo({ value: DelegatorWithdrawInfo.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDelegatorWithdrawInfo: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendValidatorSlashEventRecord({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValidatorSlashEventRecord: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.validatorSlashEventRecord({ value: ValidatorSlashEventRecord.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValidatorSlashEventRecord: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendValidatorCurrentRewards({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValidatorCurrentRewards: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.validatorCurrentRewards({ value: ValidatorCurrentRewards.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValidatorCurrentRewards: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryValidatorDistributionInfoResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryValidatorDistributionInfoResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryValidatorDistributionInfoResponse({ value: QueryValidatorDistributionInfoResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryValidatorDistributionInfoResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegatorValidatorsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegatorValidatorsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryDelegatorValidatorsResponse({ value: QueryDelegatorValidatorsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegatorValidatorsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegatorWithdrawAddressResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegatorWithdrawAddressResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryDelegatorWithdrawAddressResponse({ value: QueryDelegatorWithdrawAddressResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegatorWithdrawAddressResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetWithdrawAddress({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetWithdrawAddress: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgSetWithdrawAddress({ value: MsgSetWithdrawAddress.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetWithdrawAddress: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendFeePool({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendFeePool: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.feePool({ value: FeePool.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendFeePool: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendValidatorSlashEvent({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendValidatorSlashEvent: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.validatorSlashEvent({ value: ValidatorSlashEvent.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendValidatorSlashEvent: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryDelegatorValidatorsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryDelegatorValidatorsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryDelegatorValidatorsRequest({ value: QueryDelegatorValidatorsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryDelegatorValidatorsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        validatorSlashEvents({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvents", value: ValidatorSlashEvents.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ValidatorSlashEvents: Could not create message: ' + e.message);
            }
        },
        queryDelegatorWithdrawAddressRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressRequest", value: QueryDelegatorWithdrawAddressRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegatorWithdrawAddressRequest: Could not create message: ' + e.message);
            }
        },
        msgFundCommunityPoolResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPoolResponse", value: MsgFundCommunityPoolResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgFundCommunityPoolResponse: Could not create message: ' + e.message);
            }
        },
        msgDepositValidatorRewardsPoolResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPoolResponse", value: MsgDepositValidatorRewardsPoolResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgDepositValidatorRewardsPoolResponse: Could not create message: ' + e.message);
            }
        },
        queryValidatorCommissionRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionRequest", value: QueryValidatorCommissionRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorCommissionRequest: Could not create message: ' + e.message);
            }
        },
        queryValidatorCommissionResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionResponse", value: QueryValidatorCommissionResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorCommissionResponse: Could not create message: ' + e.message);
            }
        },
        queryDelegationRewardsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsResponse", value: QueryDelegationRewardsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegationRewardsResponse: Could not create message: ' + e.message);
            }
        },
        queryDelegationTotalRewardsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsRequest", value: QueryDelegationTotalRewardsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegationTotalRewardsRequest: Could not create message: ' + e.message);
            }
        },
        delegatorStartingInfo({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.DelegatorStartingInfo", value: DelegatorStartingInfo.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:DelegatorStartingInfo: Could not create message: ' + e.message);
            }
        },
        validatorHistoricalRewardsRecord({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.ValidatorHistoricalRewardsRecord", value: ValidatorHistoricalRewardsRecord.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ValidatorHistoricalRewardsRecord: Could not create message: ' + e.message);
            }
        },
        delegatorStartingInfoRecord({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.DelegatorStartingInfoRecord", value: DelegatorStartingInfoRecord.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:DelegatorStartingInfoRecord: Could not create message: ' + e.message);
            }
        },
        validatorHistoricalRewards({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.ValidatorHistoricalRewards", value: ValidatorHistoricalRewards.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ValidatorHistoricalRewards: Could not create message: ' + e.message);
            }
        },
        validatorCurrentRewardsRecord({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.ValidatorCurrentRewardsRecord", value: ValidatorCurrentRewardsRecord.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ValidatorCurrentRewardsRecord: Could not create message: ' + e.message);
            }
        },
        queryValidatorOutstandingRewardsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse", value: QueryValidatorOutstandingRewardsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorOutstandingRewardsResponse: Could not create message: ' + e.message);
            }
        },
        queryDelegationRewardsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsRequest", value: QueryDelegationRewardsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegationRewardsRequest: Could not create message: ' + e.message);
            }
        },
        msgSetWithdrawAddressResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddressResponse", value: MsgSetWithdrawAddressResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetWithdrawAddressResponse: Could not create message: ' + e.message);
            }
        },
        msgDepositValidatorRewardsPool({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPool", value: MsgDepositValidatorRewardsPool.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgDepositValidatorRewardsPool: Could not create message: ' + e.message);
            }
        },
        msgCommunityPoolSpendResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpendResponse", value: MsgCommunityPoolSpendResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCommunityPoolSpendResponse: Could not create message: ' + e.message);
            }
        },
        genesisState({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.GenesisState", value: GenesisState.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GenesisState: Could not create message: ' + e.message);
            }
        },
        communityPoolSpendProposal({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal", value: CommunityPoolSpendProposal.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:CommunityPoolSpendProposal: Could not create message: ' + e.message);
            }
        },
        queryCommunityPoolResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolResponse", value: QueryCommunityPoolResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryCommunityPoolResponse: Could not create message: ' + e.message);
            }
        },
        msgWithdrawDelegatorReward({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", value: MsgWithdrawDelegatorReward.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgWithdrawDelegatorReward: Could not create message: ' + e.message);
            }
        },
        msgWithdrawValidatorCommissionResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommissionResponse", value: MsgWithdrawValidatorCommissionResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgWithdrawValidatorCommissionResponse: Could not create message: ' + e.message);
            }
        },
        msgCommunityPoolSpend({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend", value: MsgCommunityPoolSpend.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCommunityPoolSpend: Could not create message: ' + e.message);
            }
        },
        validatorOutstandingRewardsRecord({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.ValidatorOutstandingRewardsRecord", value: ValidatorOutstandingRewardsRecord.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ValidatorOutstandingRewardsRecord: Could not create message: ' + e.message);
            }
        },
        msgWithdrawDelegatorRewardResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorRewardResponse", value: MsgWithdrawDelegatorRewardResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgWithdrawDelegatorRewardResponse: Could not create message: ' + e.message);
            }
        },
        params({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.Params", value: Params.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Params: Could not create message: ' + e.message);
            }
        },
        communityPoolSpendProposalWithDeposit({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit", value: CommunityPoolSpendProposalWithDeposit.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:CommunityPoolSpendProposalWithDeposit: Could not create message: ' + e.message);
            }
        },
        queryParamsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryParamsResponse", value: QueryParamsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message);
            }
        },
        queryValidatorOutstandingRewardsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsRequest", value: QueryValidatorOutstandingRewardsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorOutstandingRewardsRequest: Could not create message: ' + e.message);
            }
        },
        queryValidatorSlashesRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesRequest", value: QueryValidatorSlashesRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorSlashesRequest: Could not create message: ' + e.message);
            }
        },
        msgWithdrawValidatorCommission({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", value: MsgWithdrawValidatorCommission.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgWithdrawValidatorCommission: Could not create message: ' + e.message);
            }
        },
        msgFundCommunityPool({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool", value: MsgFundCommunityPool.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgFundCommunityPool: Could not create message: ' + e.message);
            }
        },
        msgUpdateParams({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams", value: MsgUpdateParams.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message);
            }
        },
        queryDelegationTotalRewardsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse", value: QueryDelegationTotalRewardsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegationTotalRewardsResponse: Could not create message: ' + e.message);
            }
        },
        validatorOutstandingRewards({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.ValidatorOutstandingRewards", value: ValidatorOutstandingRewards.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ValidatorOutstandingRewards: Could not create message: ' + e.message);
            }
        },
        delegationDelegatorReward({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.DelegationDelegatorReward", value: DelegationDelegatorReward.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:DelegationDelegatorReward: Could not create message: ' + e.message);
            }
        },
        queryValidatorDistributionInfoRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoRequest", value: QueryValidatorDistributionInfoRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorDistributionInfoRequest: Could not create message: ' + e.message);
            }
        },
        queryParamsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryParamsRequest", value: QueryParamsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message);
            }
        },
        queryValidatorSlashesResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesResponse", value: QueryValidatorSlashesResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorSlashesResponse: Could not create message: ' + e.message);
            }
        },
        queryCommunityPoolRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolRequest", value: QueryCommunityPoolRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryCommunityPoolRequest: Could not create message: ' + e.message);
            }
        },
        validatorAccumulatedCommissionRecord({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.ValidatorAccumulatedCommissionRecord", value: ValidatorAccumulatedCommissionRecord.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ValidatorAccumulatedCommissionRecord: Could not create message: ' + e.message);
            }
        },
        validatorAccumulatedCommission({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.ValidatorAccumulatedCommission", value: ValidatorAccumulatedCommission.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ValidatorAccumulatedCommission: Could not create message: ' + e.message);
            }
        },
        msgUpdateParamsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message);
            }
        },
        delegatorWithdrawInfo({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.DelegatorWithdrawInfo", value: DelegatorWithdrawInfo.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:DelegatorWithdrawInfo: Could not create message: ' + e.message);
            }
        },
        validatorSlashEventRecord({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEventRecord", value: ValidatorSlashEventRecord.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ValidatorSlashEventRecord: Could not create message: ' + e.message);
            }
        },
        validatorCurrentRewards({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.ValidatorCurrentRewards", value: ValidatorCurrentRewards.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ValidatorCurrentRewards: Could not create message: ' + e.message);
            }
        },
        queryValidatorDistributionInfoResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse", value: QueryValidatorDistributionInfoResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryValidatorDistributionInfoResponse: Could not create message: ' + e.message);
            }
        },
        queryDelegatorValidatorsResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse", value: QueryDelegatorValidatorsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegatorValidatorsResponse: Could not create message: ' + e.message);
            }
        },
        queryDelegatorWithdrawAddressResponse({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse", value: QueryDelegatorWithdrawAddressResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegatorWithdrawAddressResponse: Could not create message: ' + e.message);
            }
        },
        msgSetWithdrawAddress({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", value: MsgSetWithdrawAddress.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetWithdrawAddress: Could not create message: ' + e.message);
            }
        },
        feePool({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.FeePool", value: FeePool.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:FeePool: Could not create message: ' + e.message);
            }
        },
        validatorSlashEvent({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvent", value: ValidatorSlashEvent.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:ValidatorSlashEvent: Could not create message: ' + e.message);
            }
        },
        queryDelegatorValidatorsRequest({ value }) {
            try {
                return { typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsRequest", value: QueryDelegatorValidatorsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryDelegatorValidatorsRequest: Could not create message: ' + e.message);
            }
        },
    };
};
export const queryClient = ({ addr: addr } = { addr: "http://localhost:1317" }) => {
    return new Api({ baseURL: addr });
};
class SDKModule {
    constructor(client) {
        this.registry = [];
        this.query = queryClient({ addr: client.env.apiURL });
        this.updateTX(client);
        this.structure = {};
        client.on('signer-changed', (signer) => {
            this.updateTX(client);
        });
    }
    updateTX(client) {
        const methods = txClient({
            signer: client.signer,
            addr: client.env.rpcURL,
            prefix: client.env.prefix ?? "cosmos",
        });
        this.tx = methods;
        for (let m in methods) {
            this.tx[m] = methods[m].bind(this.tx);
        }
    }
}
;
const IgntModule = (test) => {
    return {
        module: {
            CosmosDistributionV1Beta1: new SDKModule(test)
        },
        registry: msgTypes
    };
};
export default IgntModule;
