// Generated by Ignite ignite.com/cli
import { SigningStargateClient } from "@cosmjs/stargate";
import { Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { Api } from "./rest";
import { MsgSendBuyOrderResponse } from "./types/dastchain/dex/tx";
import { GenesisState } from "./types/dastchain/dex/genesis";
import { QueryAllSellOrderBookResponse } from "./types/dastchain/dex/query";
import { DexPacketData } from "./types/dastchain/dex/packet";
import { Params } from "./types/dastchain/dex/params";
import { SellOrderPacketData } from "./types/dastchain/dex/packet";
import { QueryAllDenomTraceRequest } from "./types/dastchain/dex/query";
import { SellOrderPacketAck } from "./types/dastchain/dex/packet";
import { MsgSendCreatePair } from "./types/dastchain/dex/tx";
import { BuyOrderPacketData } from "./types/dastchain/dex/packet";
import { QueryAllSellOrderBookRequest } from "./types/dastchain/dex/query";
import { QueryGetBuyOrderBookRequest } from "./types/dastchain/dex/query";
import { QueryAllBuyOrderBookRequest } from "./types/dastchain/dex/query";
import { QueryGetDenomTraceResponse } from "./types/dastchain/dex/query";
import { MsgUpdateParamsResponse } from "./types/dastchain/dex/tx";
import { MsgSendSellOrderResponse } from "./types/dastchain/dex/tx";
import { QueryGetBuyOrderBookResponse } from "./types/dastchain/dex/query";
import { QueryAllDenomTraceResponse } from "./types/dastchain/dex/query";
import { MsgSendSellOrder } from "./types/dastchain/dex/tx";
import { QueryParamsResponse } from "./types/dastchain/dex/query";
import { MsgSendBuyOrder } from "./types/dastchain/dex/tx";
import { MsgCancelSellOrder } from "./types/dastchain/dex/tx";
import { MsgCancelBuyOrderResponse } from "./types/dastchain/dex/tx";
import { DenomTrace } from "./types/dastchain/dex/denom_trace";
import { QueryGetSellOrderBookRequest } from "./types/dastchain/dex/query";
import { BuyOrderBook } from "./types/dastchain/dex/buy_order_book";
import { MsgUpdateParams } from "./types/dastchain/dex/tx";
import { QueryGetDenomTraceRequest } from "./types/dastchain/dex/query";
import { MsgCancelBuyOrder } from "./types/dastchain/dex/tx";
import { SellOrderBook } from "./types/dastchain/dex/sell_order_book";
import { CreatePairPacketData } from "./types/dastchain/dex/packet";
import { QueryParamsRequest } from "./types/dastchain/dex/query";
import { QueryGetSellOrderBookResponse } from "./types/dastchain/dex/query";
import { QueryAllBuyOrderBookResponse } from "./types/dastchain/dex/query";
import { MsgSendCreatePairResponse } from "./types/dastchain/dex/tx";
import { MsgCancelSellOrderResponse } from "./types/dastchain/dex/tx";
import { BuyOrderPacketAck } from "./types/dastchain/dex/packet";
import { NoData } from "./types/dastchain/dex/packet";
import { CreatePairPacketAck } from "./types/dastchain/dex/packet";
export { MsgSendBuyOrderResponse, GenesisState, QueryAllSellOrderBookResponse, DexPacketData, Params, SellOrderPacketData, QueryAllDenomTraceRequest, SellOrderPacketAck, MsgSendCreatePair, BuyOrderPacketData, QueryAllSellOrderBookRequest, QueryGetBuyOrderBookRequest, QueryAllBuyOrderBookRequest, QueryGetDenomTraceResponse, MsgUpdateParamsResponse, MsgSendSellOrderResponse, QueryGetBuyOrderBookResponse, QueryAllDenomTraceResponse, MsgSendSellOrder, QueryParamsResponse, MsgSendBuyOrder, MsgCancelSellOrder, MsgCancelBuyOrderResponse, DenomTrace, QueryGetSellOrderBookRequest, BuyOrderBook, MsgUpdateParams, QueryGetDenomTraceRequest, MsgCancelBuyOrder, SellOrderBook, CreatePairPacketData, QueryParamsRequest, QueryGetSellOrderBookResponse, QueryAllBuyOrderBookResponse, MsgSendCreatePairResponse, MsgCancelSellOrderResponse, BuyOrderPacketAck, NoData, CreatePairPacketAck };
export const registry = new Registry(msgTypes);
function getStructure(template) {
    const structure = { fields: [] };
    for (let [key, value] of Object.entries(template)) {
        let field = { name: key, type: typeof value };
        structure.fields.push(field);
    }
    return structure;
}
const defaultFee = {
    amount: [],
    gas: "200000",
};
export const txClient = ({ signer, prefix, addr } = { addr: "http://localhost:26657", prefix: "cosmos" }) => {
    return {
        async sendMsgSendBuyOrderResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSendBuyOrderResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgSendBuyOrderResponse({ value: MsgSendBuyOrderResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSendBuyOrderResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendGenesisState({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.genesisState({ value: GenesisState.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAllSellOrderBookResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAllSellOrderBookResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryAllSellOrderBookResponse({ value: QueryAllSellOrderBookResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAllSellOrderBookResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDexPacketData({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDexPacketData: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.dexPacketData({ value: DexPacketData.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDexPacketData: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendParams({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.params({ value: Params.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendParams: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendSellOrderPacketData({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendSellOrderPacketData: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.sellOrderPacketData({ value: SellOrderPacketData.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendSellOrderPacketData: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAllDenomTraceRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAllDenomTraceRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryAllDenomTraceRequest({ value: QueryAllDenomTraceRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAllDenomTraceRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendSellOrderPacketAck({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendSellOrderPacketAck: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.sellOrderPacketAck({ value: SellOrderPacketAck.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendSellOrderPacketAck: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSendCreatePair({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSendCreatePair: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgSendCreatePair({ value: MsgSendCreatePair.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSendCreatePair: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendBuyOrderPacketData({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendBuyOrderPacketData: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.buyOrderPacketData({ value: BuyOrderPacketData.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendBuyOrderPacketData: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAllSellOrderBookRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAllSellOrderBookRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryAllSellOrderBookRequest({ value: QueryAllSellOrderBookRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAllSellOrderBookRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryGetBuyOrderBookRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryGetBuyOrderBookRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryGetBuyOrderBookRequest({ value: QueryGetBuyOrderBookRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryGetBuyOrderBookRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAllBuyOrderBookRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAllBuyOrderBookRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryAllBuyOrderBookRequest({ value: QueryAllBuyOrderBookRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAllBuyOrderBookRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryGetDenomTraceResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryGetDenomTraceResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryGetDenomTraceResponse({ value: QueryGetDenomTraceResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryGetDenomTraceResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateParamsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSendSellOrderResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSendSellOrderResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgSendSellOrderResponse({ value: MsgSendSellOrderResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSendSellOrderResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryGetBuyOrderBookResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryGetBuyOrderBookResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryGetBuyOrderBookResponse({ value: QueryGetBuyOrderBookResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryGetBuyOrderBookResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAllDenomTraceResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAllDenomTraceResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryAllDenomTraceResponse({ value: QueryAllDenomTraceResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAllDenomTraceResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSendSellOrder({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSendSellOrder: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgSendSellOrder({ value: MsgSendSellOrder.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSendSellOrder: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryParamsResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSendBuyOrder({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSendBuyOrder: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgSendBuyOrder({ value: MsgSendBuyOrder.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSendBuyOrder: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCancelSellOrder({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCancelSellOrder: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgCancelSellOrder({ value: MsgCancelSellOrder.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCancelSellOrder: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCancelBuyOrderResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCancelBuyOrderResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgCancelBuyOrderResponse({ value: MsgCancelBuyOrderResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCancelBuyOrderResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendDenomTrace({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendDenomTrace: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.denomTrace({ value: DenomTrace.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendDenomTrace: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryGetSellOrderBookRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryGetSellOrderBookRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryGetSellOrderBookRequest({ value: QueryGetSellOrderBookRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryGetSellOrderBookRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendBuyOrderBook({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendBuyOrderBook: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.buyOrderBook({ value: BuyOrderBook.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendBuyOrderBook: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateParams({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryGetDenomTraceRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryGetDenomTraceRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryGetDenomTraceRequest({ value: QueryGetDenomTraceRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryGetDenomTraceRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCancelBuyOrder({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCancelBuyOrder: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgCancelBuyOrder({ value: MsgCancelBuyOrder.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCancelBuyOrder: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendSellOrderBook({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendSellOrderBook: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.sellOrderBook({ value: SellOrderBook.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendSellOrderBook: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendCreatePairPacketData({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendCreatePairPacketData: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.createPairPacketData({ value: CreatePairPacketData.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendCreatePairPacketData: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryParamsRequest({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryGetSellOrderBookResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryGetSellOrderBookResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryGetSellOrderBookResponse({ value: QueryGetSellOrderBookResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryGetSellOrderBookResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendQueryAllBuyOrderBookResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendQueryAllBuyOrderBookResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.queryAllBuyOrderBookResponse({ value: QueryAllBuyOrderBookResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendQueryAllBuyOrderBookResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSendCreatePairResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSendCreatePairResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgSendCreatePairResponse({ value: MsgSendCreatePairResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSendCreatePairResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCancelSellOrderResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCancelSellOrderResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.msgCancelSellOrderResponse({ value: MsgCancelSellOrderResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCancelSellOrderResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendBuyOrderPacketAck({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendBuyOrderPacketAck: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.buyOrderPacketAck({ value: BuyOrderPacketAck.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendBuyOrderPacketAck: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendNoData({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendNoData: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.noData({ value: NoData.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendNoData: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendCreatePairPacketAck({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendCreatePairPacketAck: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry });
                let msg = this.createPairPacketAck({ value: CreatePairPacketAck.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendCreatePairPacketAck: Could not broadcast Tx: ' + e.message);
            }
        },
        msgSendBuyOrderResponse({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.MsgSendBuyOrderResponse", value: MsgSendBuyOrderResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSendBuyOrderResponse: Could not create message: ' + e.message);
            }
        },
        genesisState({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.GenesisState", value: GenesisState.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:GenesisState: Could not create message: ' + e.message);
            }
        },
        queryAllSellOrderBookResponse({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.QueryAllSellOrderBookResponse", value: QueryAllSellOrderBookResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAllSellOrderBookResponse: Could not create message: ' + e.message);
            }
        },
        dexPacketData({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.DexPacketData", value: DexPacketData.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:DexPacketData: Could not create message: ' + e.message);
            }
        },
        params({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.Params", value: Params.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:Params: Could not create message: ' + e.message);
            }
        },
        sellOrderPacketData({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.SellOrderPacketData", value: SellOrderPacketData.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:SellOrderPacketData: Could not create message: ' + e.message);
            }
        },
        queryAllDenomTraceRequest({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.QueryAllDenomTraceRequest", value: QueryAllDenomTraceRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAllDenomTraceRequest: Could not create message: ' + e.message);
            }
        },
        sellOrderPacketAck({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.SellOrderPacketAck", value: SellOrderPacketAck.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:SellOrderPacketAck: Could not create message: ' + e.message);
            }
        },
        msgSendCreatePair({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.MsgSendCreatePair", value: MsgSendCreatePair.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSendCreatePair: Could not create message: ' + e.message);
            }
        },
        buyOrderPacketData({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.BuyOrderPacketData", value: BuyOrderPacketData.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:BuyOrderPacketData: Could not create message: ' + e.message);
            }
        },
        queryAllSellOrderBookRequest({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.QueryAllSellOrderBookRequest", value: QueryAllSellOrderBookRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAllSellOrderBookRequest: Could not create message: ' + e.message);
            }
        },
        queryGetBuyOrderBookRequest({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.QueryGetBuyOrderBookRequest", value: QueryGetBuyOrderBookRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryGetBuyOrderBookRequest: Could not create message: ' + e.message);
            }
        },
        queryAllBuyOrderBookRequest({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.QueryAllBuyOrderBookRequest", value: QueryAllBuyOrderBookRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAllBuyOrderBookRequest: Could not create message: ' + e.message);
            }
        },
        queryGetDenomTraceResponse({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.QueryGetDenomTraceResponse", value: QueryGetDenomTraceResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryGetDenomTraceResponse: Could not create message: ' + e.message);
            }
        },
        msgUpdateParamsResponse({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message);
            }
        },
        msgSendSellOrderResponse({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.MsgSendSellOrderResponse", value: MsgSendSellOrderResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSendSellOrderResponse: Could not create message: ' + e.message);
            }
        },
        queryGetBuyOrderBookResponse({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.QueryGetBuyOrderBookResponse", value: QueryGetBuyOrderBookResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryGetBuyOrderBookResponse: Could not create message: ' + e.message);
            }
        },
        queryAllDenomTraceResponse({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.QueryAllDenomTraceResponse", value: QueryAllDenomTraceResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAllDenomTraceResponse: Could not create message: ' + e.message);
            }
        },
        msgSendSellOrder({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.MsgSendSellOrder", value: MsgSendSellOrder.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSendSellOrder: Could not create message: ' + e.message);
            }
        },
        queryParamsResponse({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.QueryParamsResponse", value: QueryParamsResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message);
            }
        },
        msgSendBuyOrder({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.MsgSendBuyOrder", value: MsgSendBuyOrder.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSendBuyOrder: Could not create message: ' + e.message);
            }
        },
        msgCancelSellOrder({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.MsgCancelSellOrder", value: MsgCancelSellOrder.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCancelSellOrder: Could not create message: ' + e.message);
            }
        },
        msgCancelBuyOrderResponse({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.MsgCancelBuyOrderResponse", value: MsgCancelBuyOrderResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCancelBuyOrderResponse: Could not create message: ' + e.message);
            }
        },
        denomTrace({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.DenomTrace", value: DenomTrace.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:DenomTrace: Could not create message: ' + e.message);
            }
        },
        queryGetSellOrderBookRequest({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.QueryGetSellOrderBookRequest", value: QueryGetSellOrderBookRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryGetSellOrderBookRequest: Could not create message: ' + e.message);
            }
        },
        buyOrderBook({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.BuyOrderBook", value: BuyOrderBook.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:BuyOrderBook: Could not create message: ' + e.message);
            }
        },
        msgUpdateParams({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.MsgUpdateParams", value: MsgUpdateParams.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message);
            }
        },
        queryGetDenomTraceRequest({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.QueryGetDenomTraceRequest", value: QueryGetDenomTraceRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryGetDenomTraceRequest: Could not create message: ' + e.message);
            }
        },
        msgCancelBuyOrder({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.MsgCancelBuyOrder", value: MsgCancelBuyOrder.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCancelBuyOrder: Could not create message: ' + e.message);
            }
        },
        sellOrderBook({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.SellOrderBook", value: SellOrderBook.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:SellOrderBook: Could not create message: ' + e.message);
            }
        },
        createPairPacketData({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.CreatePairPacketData", value: CreatePairPacketData.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:CreatePairPacketData: Could not create message: ' + e.message);
            }
        },
        queryParamsRequest({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.QueryParamsRequest", value: QueryParamsRequest.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message);
            }
        },
        queryGetSellOrderBookResponse({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.QueryGetSellOrderBookResponse", value: QueryGetSellOrderBookResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryGetSellOrderBookResponse: Could not create message: ' + e.message);
            }
        },
        queryAllBuyOrderBookResponse({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.QueryAllBuyOrderBookResponse", value: QueryAllBuyOrderBookResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:QueryAllBuyOrderBookResponse: Could not create message: ' + e.message);
            }
        },
        msgSendCreatePairResponse({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.MsgSendCreatePairResponse", value: MsgSendCreatePairResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSendCreatePairResponse: Could not create message: ' + e.message);
            }
        },
        msgCancelSellOrderResponse({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.MsgCancelSellOrderResponse", value: MsgCancelSellOrderResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCancelSellOrderResponse: Could not create message: ' + e.message);
            }
        },
        buyOrderPacketAck({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.BuyOrderPacketAck", value: BuyOrderPacketAck.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:BuyOrderPacketAck: Could not create message: ' + e.message);
            }
        },
        noData({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.NoData", value: NoData.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:NoData: Could not create message: ' + e.message);
            }
        },
        createPairPacketAck({ value }) {
            try {
                return { typeUrl: "/dastchain.dex.CreatePairPacketAck", value: CreatePairPacketAck.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:CreatePairPacketAck: Could not create message: ' + e.message);
            }
        },
    };
};
export const queryClient = ({ addr: addr } = { addr: "http://localhost:1317" }) => {
    return new Api({ baseURL: addr });
};
class SDKModule {
    constructor(client) {
        this.registry = [];
        this.query = queryClient({ addr: client.env.apiURL });
        this.updateTX(client);
        this.structure = {};
        client.on('signer-changed', (signer) => {
            this.updateTX(client);
        });
    }
    updateTX(client) {
        const methods = txClient({
            signer: client.signer,
            addr: client.env.rpcURL,
            prefix: client.env.prefix ?? "cosmos",
        });
        this.tx = methods;
        for (let m in methods) {
            this.tx[m] = methods[m].bind(this.tx);
        }
    }
}
;
const IgntModule = (test) => {
    return {
        module: {
            DastchainDex: new SDKModule(test)
        },
        registry: msgTypes
    };
};
export default IgntModule;
