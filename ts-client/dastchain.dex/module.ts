// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { MsgSendBuyOrderResponse } from "./types/dastchain/dex/tx";
import { GenesisState } from "./types/dastchain/dex/genesis";
import { QueryAllSellOrderBookResponse } from "./types/dastchain/dex/query";
import { DexPacketData } from "./types/dastchain/dex/packet";
import { Params } from "./types/dastchain/dex/params";
import { SellOrderPacketData } from "./types/dastchain/dex/packet";
import { QueryAllDenomTraceRequest } from "./types/dastchain/dex/query";
import { SellOrderPacketAck } from "./types/dastchain/dex/packet";
import { MsgSendCreatePair } from "./types/dastchain/dex/tx";
import { BuyOrderPacketData } from "./types/dastchain/dex/packet";
import { QueryAllSellOrderBookRequest } from "./types/dastchain/dex/query";
import { QueryGetBuyOrderBookRequest } from "./types/dastchain/dex/query";
import { QueryAllBuyOrderBookRequest } from "./types/dastchain/dex/query";
import { QueryGetDenomTraceResponse } from "./types/dastchain/dex/query";
import { MsgUpdateParamsResponse } from "./types/dastchain/dex/tx";
import { MsgSendSellOrderResponse } from "./types/dastchain/dex/tx";
import { QueryGetBuyOrderBookResponse } from "./types/dastchain/dex/query";
import { QueryAllDenomTraceResponse } from "./types/dastchain/dex/query";
import { MsgSendSellOrder } from "./types/dastchain/dex/tx";
import { QueryParamsResponse } from "./types/dastchain/dex/query";
import { MsgSendBuyOrder } from "./types/dastchain/dex/tx";
import { MsgCancelSellOrder } from "./types/dastchain/dex/tx";
import { MsgCancelBuyOrderResponse } from "./types/dastchain/dex/tx";
import { DenomTrace } from "./types/dastchain/dex/denom_trace";
import { QueryGetSellOrderBookRequest } from "./types/dastchain/dex/query";
import { BuyOrderBook } from "./types/dastchain/dex/buy_order_book";
import { MsgUpdateParams } from "./types/dastchain/dex/tx";
import { QueryGetDenomTraceRequest } from "./types/dastchain/dex/query";
import { MsgCancelBuyOrder } from "./types/dastchain/dex/tx";
import { SellOrderBook } from "./types/dastchain/dex/sell_order_book";
import { CreatePairPacketData } from "./types/dastchain/dex/packet";
import { QueryParamsRequest } from "./types/dastchain/dex/query";
import { QueryGetSellOrderBookResponse } from "./types/dastchain/dex/query";
import { QueryAllBuyOrderBookResponse } from "./types/dastchain/dex/query";
import { MsgSendCreatePairResponse } from "./types/dastchain/dex/tx";
import { MsgCancelSellOrderResponse } from "./types/dastchain/dex/tx";
import { BuyOrderPacketAck } from "./types/dastchain/dex/packet";
import { NoData } from "./types/dastchain/dex/packet";
import { CreatePairPacketAck } from "./types/dastchain/dex/packet";


export { MsgSendBuyOrderResponse, GenesisState, QueryAllSellOrderBookResponse, DexPacketData, Params, SellOrderPacketData, QueryAllDenomTraceRequest, SellOrderPacketAck, MsgSendCreatePair, BuyOrderPacketData, QueryAllSellOrderBookRequest, QueryGetBuyOrderBookRequest, QueryAllBuyOrderBookRequest, QueryGetDenomTraceResponse, MsgUpdateParamsResponse, MsgSendSellOrderResponse, QueryGetBuyOrderBookResponse, QueryAllDenomTraceResponse, MsgSendSellOrder, QueryParamsResponse, MsgSendBuyOrder, MsgCancelSellOrder, MsgCancelBuyOrderResponse, DenomTrace, QueryGetSellOrderBookRequest, BuyOrderBook, MsgUpdateParams, QueryGetDenomTraceRequest, MsgCancelBuyOrder, SellOrderBook, CreatePairPacketData, QueryParamsRequest, QueryGetSellOrderBookResponse, QueryAllBuyOrderBookResponse, MsgSendCreatePairResponse, MsgCancelSellOrderResponse, BuyOrderPacketAck, NoData, CreatePairPacketAck };

type sendMsgSendBuyOrderResponseParams = {
  value: MsgSendBuyOrderResponse,
  fee?: StdFee,
  memo?: string
};

type sendGenesisStateParams = {
  value: GenesisState,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllSellOrderBookResponseParams = {
  value: QueryAllSellOrderBookResponse,
  fee?: StdFee,
  memo?: string
};

type sendDexPacketDataParams = {
  value: DexPacketData,
  fee?: StdFee,
  memo?: string
};

type sendParamsParams = {
  value: Params,
  fee?: StdFee,
  memo?: string
};

type sendSellOrderPacketDataParams = {
  value: SellOrderPacketData,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllDenomTraceRequestParams = {
  value: QueryAllDenomTraceRequest,
  fee?: StdFee,
  memo?: string
};

type sendSellOrderPacketAckParams = {
  value: SellOrderPacketAck,
  fee?: StdFee,
  memo?: string
};

type sendMsgSendCreatePairParams = {
  value: MsgSendCreatePair,
  fee?: StdFee,
  memo?: string
};

type sendBuyOrderPacketDataParams = {
  value: BuyOrderPacketData,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllSellOrderBookRequestParams = {
  value: QueryAllSellOrderBookRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetBuyOrderBookRequestParams = {
  value: QueryGetBuyOrderBookRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllBuyOrderBookRequestParams = {
  value: QueryAllBuyOrderBookRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetDenomTraceResponseParams = {
  value: QueryGetDenomTraceResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgSendSellOrderResponseParams = {
  value: MsgSendSellOrderResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetBuyOrderBookResponseParams = {
  value: QueryGetBuyOrderBookResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllDenomTraceResponseParams = {
  value: QueryAllDenomTraceResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgSendSellOrderParams = {
  value: MsgSendSellOrder,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsResponseParams = {
  value: QueryParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgSendBuyOrderParams = {
  value: MsgSendBuyOrder,
  fee?: StdFee,
  memo?: string
};

type sendMsgCancelSellOrderParams = {
  value: MsgCancelSellOrder,
  fee?: StdFee,
  memo?: string
};

type sendMsgCancelBuyOrderResponseParams = {
  value: MsgCancelBuyOrderResponse,
  fee?: StdFee,
  memo?: string
};

type sendDenomTraceParams = {
  value: DenomTrace,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetSellOrderBookRequestParams = {
  value: QueryGetSellOrderBookRequest,
  fee?: StdFee,
  memo?: string
};

type sendBuyOrderBookParams = {
  value: BuyOrderBook,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetDenomTraceRequestParams = {
  value: QueryGetDenomTraceRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgCancelBuyOrderParams = {
  value: MsgCancelBuyOrder,
  fee?: StdFee,
  memo?: string
};

type sendSellOrderBookParams = {
  value: SellOrderBook,
  fee?: StdFee,
  memo?: string
};

type sendCreatePairPacketDataParams = {
  value: CreatePairPacketData,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsRequestParams = {
  value: QueryParamsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetSellOrderBookResponseParams = {
  value: QueryGetSellOrderBookResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllBuyOrderBookResponseParams = {
  value: QueryAllBuyOrderBookResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgSendCreatePairResponseParams = {
  value: MsgSendCreatePairResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgCancelSellOrderResponseParams = {
  value: MsgCancelSellOrderResponse,
  fee?: StdFee,
  memo?: string
};

type sendBuyOrderPacketAckParams = {
  value: BuyOrderPacketAck,
  fee?: StdFee,
  memo?: string
};

type sendNoDataParams = {
  value: NoData,
  fee?: StdFee,
  memo?: string
};

type sendCreatePairPacketAckParams = {
  value: CreatePairPacketAck,
  fee?: StdFee,
  memo?: string
};


type msgSendBuyOrderResponseParams = {
  value: MsgSendBuyOrderResponse,
};

type genesisStateParams = {
  value: GenesisState,
};

type queryAllSellOrderBookResponseParams = {
  value: QueryAllSellOrderBookResponse,
};

type dexPacketDataParams = {
  value: DexPacketData,
};

type paramsParams = {
  value: Params,
};

type sellOrderPacketDataParams = {
  value: SellOrderPacketData,
};

type queryAllDenomTraceRequestParams = {
  value: QueryAllDenomTraceRequest,
};

type sellOrderPacketAckParams = {
  value: SellOrderPacketAck,
};

type msgSendCreatePairParams = {
  value: MsgSendCreatePair,
};

type buyOrderPacketDataParams = {
  value: BuyOrderPacketData,
};

type queryAllSellOrderBookRequestParams = {
  value: QueryAllSellOrderBookRequest,
};

type queryGetBuyOrderBookRequestParams = {
  value: QueryGetBuyOrderBookRequest,
};

type queryAllBuyOrderBookRequestParams = {
  value: QueryAllBuyOrderBookRequest,
};

type queryGetDenomTraceResponseParams = {
  value: QueryGetDenomTraceResponse,
};

type msgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
};

type msgSendSellOrderResponseParams = {
  value: MsgSendSellOrderResponse,
};

type queryGetBuyOrderBookResponseParams = {
  value: QueryGetBuyOrderBookResponse,
};

type queryAllDenomTraceResponseParams = {
  value: QueryAllDenomTraceResponse,
};

type msgSendSellOrderParams = {
  value: MsgSendSellOrder,
};

type queryParamsResponseParams = {
  value: QueryParamsResponse,
};

type msgSendBuyOrderParams = {
  value: MsgSendBuyOrder,
};

type msgCancelSellOrderParams = {
  value: MsgCancelSellOrder,
};

type msgCancelBuyOrderResponseParams = {
  value: MsgCancelBuyOrderResponse,
};

type denomTraceParams = {
  value: DenomTrace,
};

type queryGetSellOrderBookRequestParams = {
  value: QueryGetSellOrderBookRequest,
};

type buyOrderBookParams = {
  value: BuyOrderBook,
};

type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type queryGetDenomTraceRequestParams = {
  value: QueryGetDenomTraceRequest,
};

type msgCancelBuyOrderParams = {
  value: MsgCancelBuyOrder,
};

type sellOrderBookParams = {
  value: SellOrderBook,
};

type createPairPacketDataParams = {
  value: CreatePairPacketData,
};

type queryParamsRequestParams = {
  value: QueryParamsRequest,
};

type queryGetSellOrderBookResponseParams = {
  value: QueryGetSellOrderBookResponse,
};

type queryAllBuyOrderBookResponseParams = {
  value: QueryAllBuyOrderBookResponse,
};

type msgSendCreatePairResponseParams = {
  value: MsgSendCreatePairResponse,
};

type msgCancelSellOrderResponseParams = {
  value: MsgCancelSellOrderResponse,
};

type buyOrderPacketAckParams = {
  value: BuyOrderPacketAck,
};

type noDataParams = {
  value: NoData,
};

type createPairPacketAckParams = {
  value: CreatePairPacketAck,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendMsgSendBuyOrderResponse({ value, fee, memo }: sendMsgSendBuyOrderResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSendBuyOrderResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSendBuyOrderResponse({ value: MsgSendBuyOrderResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSendBuyOrderResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisState({ value, fee, memo }: sendGenesisStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisState({ value: GenesisState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllSellOrderBookResponse({ value, fee, memo }: sendQueryAllSellOrderBookResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllSellOrderBookResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllSellOrderBookResponse({ value: QueryAllSellOrderBookResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllSellOrderBookResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendDexPacketData({ value, fee, memo }: sendDexPacketDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendDexPacketData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.dexPacketData({ value: DexPacketData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendDexPacketData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendParams({ value, fee, memo }: sendParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.params({ value: Params.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendSellOrderPacketData({ value, fee, memo }: sendSellOrderPacketDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendSellOrderPacketData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.sellOrderPacketData({ value: SellOrderPacketData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendSellOrderPacketData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllDenomTraceRequest({ value, fee, memo }: sendQueryAllDenomTraceRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllDenomTraceRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllDenomTraceRequest({ value: QueryAllDenomTraceRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllDenomTraceRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendSellOrderPacketAck({ value, fee, memo }: sendSellOrderPacketAckParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendSellOrderPacketAck: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.sellOrderPacketAck({ value: SellOrderPacketAck.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendSellOrderPacketAck: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSendCreatePair({ value, fee, memo }: sendMsgSendCreatePairParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSendCreatePair: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSendCreatePair({ value: MsgSendCreatePair.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSendCreatePair: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendBuyOrderPacketData({ value, fee, memo }: sendBuyOrderPacketDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendBuyOrderPacketData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.buyOrderPacketData({ value: BuyOrderPacketData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendBuyOrderPacketData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllSellOrderBookRequest({ value, fee, memo }: sendQueryAllSellOrderBookRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllSellOrderBookRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllSellOrderBookRequest({ value: QueryAllSellOrderBookRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllSellOrderBookRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetBuyOrderBookRequest({ value, fee, memo }: sendQueryGetBuyOrderBookRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetBuyOrderBookRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetBuyOrderBookRequest({ value: QueryGetBuyOrderBookRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetBuyOrderBookRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllBuyOrderBookRequest({ value, fee, memo }: sendQueryAllBuyOrderBookRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllBuyOrderBookRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllBuyOrderBookRequest({ value: QueryAllBuyOrderBookRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllBuyOrderBookRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetDenomTraceResponse({ value, fee, memo }: sendQueryGetDenomTraceResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetDenomTraceResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetDenomTraceResponse({ value: QueryGetDenomTraceResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetDenomTraceResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParamsResponse({ value, fee, memo }: sendMsgUpdateParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSendSellOrderResponse({ value, fee, memo }: sendMsgSendSellOrderResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSendSellOrderResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSendSellOrderResponse({ value: MsgSendSellOrderResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSendSellOrderResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetBuyOrderBookResponse({ value, fee, memo }: sendQueryGetBuyOrderBookResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetBuyOrderBookResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetBuyOrderBookResponse({ value: QueryGetBuyOrderBookResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetBuyOrderBookResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllDenomTraceResponse({ value, fee, memo }: sendQueryAllDenomTraceResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllDenomTraceResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllDenomTraceResponse({ value: QueryAllDenomTraceResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllDenomTraceResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSendSellOrder({ value, fee, memo }: sendMsgSendSellOrderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSendSellOrder: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSendSellOrder({ value: MsgSendSellOrder.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSendSellOrder: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsResponse({ value, fee, memo }: sendQueryParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSendBuyOrder({ value, fee, memo }: sendMsgSendBuyOrderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSendBuyOrder: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSendBuyOrder({ value: MsgSendBuyOrder.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSendBuyOrder: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCancelSellOrder({ value, fee, memo }: sendMsgCancelSellOrderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCancelSellOrder: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCancelSellOrder({ value: MsgCancelSellOrder.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCancelSellOrder: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCancelBuyOrderResponse({ value, fee, memo }: sendMsgCancelBuyOrderResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCancelBuyOrderResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCancelBuyOrderResponse({ value: MsgCancelBuyOrderResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCancelBuyOrderResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendDenomTrace({ value, fee, memo }: sendDenomTraceParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendDenomTrace: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.denomTrace({ value: DenomTrace.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendDenomTrace: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetSellOrderBookRequest({ value, fee, memo }: sendQueryGetSellOrderBookRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetSellOrderBookRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetSellOrderBookRequest({ value: QueryGetSellOrderBookRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetSellOrderBookRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendBuyOrderBook({ value, fee, memo }: sendBuyOrderBookParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendBuyOrderBook: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.buyOrderBook({ value: BuyOrderBook.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendBuyOrderBook: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetDenomTraceRequest({ value, fee, memo }: sendQueryGetDenomTraceRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetDenomTraceRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetDenomTraceRequest({ value: QueryGetDenomTraceRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetDenomTraceRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCancelBuyOrder({ value, fee, memo }: sendMsgCancelBuyOrderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCancelBuyOrder: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCancelBuyOrder({ value: MsgCancelBuyOrder.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCancelBuyOrder: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendSellOrderBook({ value, fee, memo }: sendSellOrderBookParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendSellOrderBook: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.sellOrderBook({ value: SellOrderBook.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendSellOrderBook: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendCreatePairPacketData({ value, fee, memo }: sendCreatePairPacketDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendCreatePairPacketData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.createPairPacketData({ value: CreatePairPacketData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendCreatePairPacketData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsRequest({ value, fee, memo }: sendQueryParamsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetSellOrderBookResponse({ value, fee, memo }: sendQueryGetSellOrderBookResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetSellOrderBookResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetSellOrderBookResponse({ value: QueryGetSellOrderBookResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetSellOrderBookResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllBuyOrderBookResponse({ value, fee, memo }: sendQueryAllBuyOrderBookResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllBuyOrderBookResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllBuyOrderBookResponse({ value: QueryAllBuyOrderBookResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllBuyOrderBookResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSendCreatePairResponse({ value, fee, memo }: sendMsgSendCreatePairResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSendCreatePairResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSendCreatePairResponse({ value: MsgSendCreatePairResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSendCreatePairResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCancelSellOrderResponse({ value, fee, memo }: sendMsgCancelSellOrderResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCancelSellOrderResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCancelSellOrderResponse({ value: MsgCancelSellOrderResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCancelSellOrderResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendBuyOrderPacketAck({ value, fee, memo }: sendBuyOrderPacketAckParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendBuyOrderPacketAck: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.buyOrderPacketAck({ value: BuyOrderPacketAck.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendBuyOrderPacketAck: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendNoData({ value, fee, memo }: sendNoDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendNoData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.noData({ value: NoData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendNoData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendCreatePairPacketAck({ value, fee, memo }: sendCreatePairPacketAckParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendCreatePairPacketAck: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.createPairPacketAck({ value: CreatePairPacketAck.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendCreatePairPacketAck: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		msgSendBuyOrderResponse({ value }: msgSendBuyOrderResponseParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.MsgSendBuyOrderResponse", value: MsgSendBuyOrderResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSendBuyOrderResponse: Could not create message: ' + e.message)
			}
		},
		
		genesisState({ value }: genesisStateParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.GenesisState", value: GenesisState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisState: Could not create message: ' + e.message)
			}
		},
		
		queryAllSellOrderBookResponse({ value }: queryAllSellOrderBookResponseParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.QueryAllSellOrderBookResponse", value: QueryAllSellOrderBookResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllSellOrderBookResponse: Could not create message: ' + e.message)
			}
		},
		
		dexPacketData({ value }: dexPacketDataParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.DexPacketData", value: DexPacketData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:DexPacketData: Could not create message: ' + e.message)
			}
		},
		
		params({ value }: paramsParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.Params", value: Params.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Params: Could not create message: ' + e.message)
			}
		},
		
		sellOrderPacketData({ value }: sellOrderPacketDataParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.SellOrderPacketData", value: SellOrderPacketData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:SellOrderPacketData: Could not create message: ' + e.message)
			}
		},
		
		queryAllDenomTraceRequest({ value }: queryAllDenomTraceRequestParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.QueryAllDenomTraceRequest", value: QueryAllDenomTraceRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllDenomTraceRequest: Could not create message: ' + e.message)
			}
		},
		
		sellOrderPacketAck({ value }: sellOrderPacketAckParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.SellOrderPacketAck", value: SellOrderPacketAck.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:SellOrderPacketAck: Could not create message: ' + e.message)
			}
		},
		
		msgSendCreatePair({ value }: msgSendCreatePairParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.MsgSendCreatePair", value: MsgSendCreatePair.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSendCreatePair: Could not create message: ' + e.message)
			}
		},
		
		buyOrderPacketData({ value }: buyOrderPacketDataParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.BuyOrderPacketData", value: BuyOrderPacketData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:BuyOrderPacketData: Could not create message: ' + e.message)
			}
		},
		
		queryAllSellOrderBookRequest({ value }: queryAllSellOrderBookRequestParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.QueryAllSellOrderBookRequest", value: QueryAllSellOrderBookRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllSellOrderBookRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetBuyOrderBookRequest({ value }: queryGetBuyOrderBookRequestParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.QueryGetBuyOrderBookRequest", value: QueryGetBuyOrderBookRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetBuyOrderBookRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllBuyOrderBookRequest({ value }: queryAllBuyOrderBookRequestParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.QueryAllBuyOrderBookRequest", value: QueryAllBuyOrderBookRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllBuyOrderBookRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetDenomTraceResponse({ value }: queryGetDenomTraceResponseParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.QueryGetDenomTraceResponse", value: QueryGetDenomTraceResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetDenomTraceResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParamsResponse({ value }: msgUpdateParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgSendSellOrderResponse({ value }: msgSendSellOrderResponseParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.MsgSendSellOrderResponse", value: MsgSendSellOrderResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSendSellOrderResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetBuyOrderBookResponse({ value }: queryGetBuyOrderBookResponseParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.QueryGetBuyOrderBookResponse", value: QueryGetBuyOrderBookResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetBuyOrderBookResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllDenomTraceResponse({ value }: queryAllDenomTraceResponseParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.QueryAllDenomTraceResponse", value: QueryAllDenomTraceResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllDenomTraceResponse: Could not create message: ' + e.message)
			}
		},
		
		msgSendSellOrder({ value }: msgSendSellOrderParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.MsgSendSellOrder", value: MsgSendSellOrder.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSendSellOrder: Could not create message: ' + e.message)
			}
		},
		
		queryParamsResponse({ value }: queryParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.QueryParamsResponse", value: QueryParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgSendBuyOrder({ value }: msgSendBuyOrderParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.MsgSendBuyOrder", value: MsgSendBuyOrder.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSendBuyOrder: Could not create message: ' + e.message)
			}
		},
		
		msgCancelSellOrder({ value }: msgCancelSellOrderParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.MsgCancelSellOrder", value: MsgCancelSellOrder.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCancelSellOrder: Could not create message: ' + e.message)
			}
		},
		
		msgCancelBuyOrderResponse({ value }: msgCancelBuyOrderResponseParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.MsgCancelBuyOrderResponse", value: MsgCancelBuyOrderResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCancelBuyOrderResponse: Could not create message: ' + e.message)
			}
		},
		
		denomTrace({ value }: denomTraceParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.DenomTrace", value: DenomTrace.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:DenomTrace: Could not create message: ' + e.message)
			}
		},
		
		queryGetSellOrderBookRequest({ value }: queryGetSellOrderBookRequestParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.QueryGetSellOrderBookRequest", value: QueryGetSellOrderBookRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetSellOrderBookRequest: Could not create message: ' + e.message)
			}
		},
		
		buyOrderBook({ value }: buyOrderBookParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.BuyOrderBook", value: BuyOrderBook.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:BuyOrderBook: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		queryGetDenomTraceRequest({ value }: queryGetDenomTraceRequestParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.QueryGetDenomTraceRequest", value: QueryGetDenomTraceRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetDenomTraceRequest: Could not create message: ' + e.message)
			}
		},
		
		msgCancelBuyOrder({ value }: msgCancelBuyOrderParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.MsgCancelBuyOrder", value: MsgCancelBuyOrder.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCancelBuyOrder: Could not create message: ' + e.message)
			}
		},
		
		sellOrderBook({ value }: sellOrderBookParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.SellOrderBook", value: SellOrderBook.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:SellOrderBook: Could not create message: ' + e.message)
			}
		},
		
		createPairPacketData({ value }: createPairPacketDataParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.CreatePairPacketData", value: CreatePairPacketData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:CreatePairPacketData: Could not create message: ' + e.message)
			}
		},
		
		queryParamsRequest({ value }: queryParamsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.QueryParamsRequest", value: QueryParamsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetSellOrderBookResponse({ value }: queryGetSellOrderBookResponseParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.QueryGetSellOrderBookResponse", value: QueryGetSellOrderBookResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetSellOrderBookResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllBuyOrderBookResponse({ value }: queryAllBuyOrderBookResponseParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.QueryAllBuyOrderBookResponse", value: QueryAllBuyOrderBookResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllBuyOrderBookResponse: Could not create message: ' + e.message)
			}
		},
		
		msgSendCreatePairResponse({ value }: msgSendCreatePairResponseParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.MsgSendCreatePairResponse", value: MsgSendCreatePairResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSendCreatePairResponse: Could not create message: ' + e.message)
			}
		},
		
		msgCancelSellOrderResponse({ value }: msgCancelSellOrderResponseParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.MsgCancelSellOrderResponse", value: MsgCancelSellOrderResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCancelSellOrderResponse: Could not create message: ' + e.message)
			}
		},
		
		buyOrderPacketAck({ value }: buyOrderPacketAckParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.BuyOrderPacketAck", value: BuyOrderPacketAck.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:BuyOrderPacketAck: Could not create message: ' + e.message)
			}
		},
		
		noData({ value }: noDataParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.NoData", value: NoData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:NoData: Could not create message: ' + e.message)
			}
		},
		
		createPairPacketAck({ value }: createPairPacketAckParams): EncodeObject {
			try {
				return { typeUrl: "/dastchain.dex.CreatePairPacketAck", value: CreatePairPacketAck.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:CreatePairPacketAck: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			DastchainDex: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;